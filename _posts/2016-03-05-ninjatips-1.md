---
layout: post
title: NinjaTips #1
author: acrepet
tags: ["Angular 2", "template", "html"]
description: "moteur de parsing HTML propre dans Angular 2"
---

# NinjaTips #1
Les ninjas se lancent dans l'écriture de *Ninja Tips*! On a envie de vous faire partager les trucs et astuces que l'on découvre et qui nous plaisent. On se dit que cela pourrait être sympa que l'on vous explique des petits (ou gros) problèmes que l'on a pu rencontré au quotidien dans nos projets, en vous donnant quelques pistes de solutions…

Malgré le fait que nous pouvons être des champions de la [procrastination](http://waitbutwhy.com/2013/10/why-procrastinators-procrastinate.html){:target="_blank"}, nous nous lançons donc dans des petits posts courts mais réguliers, ! Les sujets viendront au fur et à mesure des semaines, en fonction des problèmes que l'on rencontre, de nos lectures ou des derniers sujets auxquels [JB](http://stackoverflow.com/users/571407/jb-nizet){:target="_blank"} a répondu sous stackoverflow.

# Un nouveau moteur de parsing HTML
 
Saviez-vous qu'Angular 2 inclue son propre moteur de parsing HTML?

Mais pourquoi donc me diriez-vous? Et bien pour plein de bonnes raisons…

La [raison principale](http://angularjs.blogspot.fr/2016/02/angular-2-templates-will-it-parse.html){:target="_blank"}, énoncée officiellement par la team Angular 2, est l'élimination de la convention de mapping qu'il y avait en Angular 1 entre les attributs de template (en kebab-case) et les attributs de vos directives (attendus en camelCase). 

Pour celles et ceux qui se sont un peu amusés avec Angular 1, vous vous êtes sûrement faits avoir au moins une fois sur un problème entre le nom que vous donniez à un attribut de votre template, donc respectant la convention kebab-case, par exemple&nbsp;:

    <div ninja-poney>This awesome poney</div>

et le nom attendu par le framework sur votre attribut JavaScript de la directive, en camelCase&nbsp;:

    app.directive('ninjaPoney', function() {
      return {
        template: '<h1>Poney</h1>'
      };
    });


Nous aurions préféré pouvoir écrire le template comme suit&nbsp;:

    <div ninjaPoney>This awesome poney</div>


Dorénavant en Angular 2, c'est possible, les noms des attributs seront case-sensitive . Mais comment est-ce possible? Et bien oui, les naviguateurs ne différencient pas les tags selon la casse, HTML est case-insensitive. Donc la solution pour la team Angular 2 a été de développer leur propre moteur de parsing HTML. Ourch!

Au niveau IDE, il y a encore un travail d'intégration en cours (remontez [vos problèmes](https://github.com/angular/angular/issues/new) d'ailleurs si vous en rencontrez) pour que vous puissiez facilement écrire des templates avec des attributs HTML en camelCase.

Mais à part ce petit bémol temporaire, c'est plutôt sympa de garder une cohérence entre les noms des attributs des composants ou directives et ceux des templates. Et il y a bien sûr quelques autres avantages au fait de disposer d'un moteur de parsing HTML propre à Angular 2...

# Des templates plus faciles à développer!

Les templates Angular 2 sont valides au niveau HTML et donc si vous faites une erreur HTML, vous serez alertés avec des messages d'erreurs précis. Si par exemple vous écrivez&nbsp;:
 
    <div>
      <img [src]="..."></img>
    </div>

L'erreur suivante sera remontée par le framework&nbsp;:

    EXCEPTION: Template parse errors:
    Void elements do not have end tags "img" ("<div>
    <img [src]="getPonyImageUrl(pony)">[ERROR ->]</img>
    </div>"): Pony@1:39 BrowserDomAdapter.logError @ angular2.dev.js:23083

Et bien oui la spec HTML dit bien qu'il ne faut pas de balise fermante pour le tag <img>! Et là remarquez qu'on vous donne dans l'erreur les numéros de ligne et de colonne où le problème apparaît dans le template. Cool non? 

Un autre avantage au fait d'avoir un moteur de parsing HTML propre dans Angular 2 c'est que, quel que soit votre naviguateur, le template est parsé de la même manière (le framework a d'ailleurs été épuré au passage de tout le code spécifique qui était nécessaire pour supporter les différents naviguateurs du marché). Avec Angular 2, vous aurez la garantie que vos templates seront réellement valides au niveau HTML, avant le déploiement et pour tous les naviguateurs!

A savoir également que, sous le capot, le nouveau support i18n d'Angular 2 nécessite de parser les templates. Leur parseur spécifique leur permet donc de gérer l'internationalisation de manière plus simple, plus fiable et efficace.


